#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
CS 112: Programming Games: Introduction to Programming using Python and
 Pygame
\end_layout

\begin_layout Title
Spring 2012 lectures
\end_layout

\begin_layout Author
Paul Dickson
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Itemize
this class is a Python programming class
\end_layout

\begin_layout Itemize
learn Python in the content of game creation
\end_layout

\begin_layout Itemize
why Python?
\end_layout

\begin_deeper
\begin_layout Itemize
easy
\end_layout

\begin_layout Itemize
game libraries exist
\end_layout

\begin_layout Itemize
python is starting to be everywhere
\end_layout

\begin_deeper
\begin_layout Itemize
scripting
\end_layout

\begin_layout Itemize
web servers
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
should be fun
\end_layout

\begin_layout Itemize
first time course is being taught
\end_layout

\begin_layout Itemize
class website will have everything
\end_layout

\begin_layout Itemize
TAs
\end_layout

\begin_deeper
\begin_layout Itemize
Alec
\end_layout

\begin_layout Itemize
Jonah
\end_layout

\begin_layout Itemize
Jack
\end_layout

\end_deeper
\begin_layout Subsection
Structure of course
\end_layout

\begin_layout Itemize
discuss point policy on assignments (1 point needed for every assignment)
\end_layout

\begin_deeper
\begin_layout Itemize
+2 early
\end_layout

\begin_layout Itemize
+1 on time 
\end_layout

\begin_layout Itemize
0 late
\end_layout

\begin_layout Itemize
-2 not turned in at all
\end_layout

\end_deeper
\begin_layout Itemize
why point policy
\end_layout

\begin_deeper
\begin_layout Itemize
if you don't keep up you're screwed
\end_layout

\end_deeper
\begin_layout Subsection
Textbook/reading policy
\end_layout

\begin_layout Itemize
first time trying a free (downloadable) text, we'll see how it goes
\end_layout

\begin_layout Subsection
Get to know each other
\end_layout

\begin_layout Itemize
this works best if they're comfortable chatting
\end_layout

\begin_layout Itemize
go around and ask 
\end_layout

\begin_deeper
\begin_layout Itemize
names
\end_layout

\begin_layout Itemize
why they took course
\end_layout

\begin_layout Itemize
what they hope to get
\end_layout

\begin_layout Itemize
etc.
\end_layout

\end_deeper
\begin_layout Subsection
Python
\end_layout

\begin_layout Itemize
interpreted language 
\end_layout

\begin_deeper
\begin_layout Itemize
code is interpreted
\end_layout

\begin_layout Itemize
not compiled like C, Java, etc
\end_layout

\end_deeper
\begin_layout Subsection
My first program
\end_layout

\begin_layout Itemize
open terminal
\end_layout

\begin_layout Itemize
have them type
\end_layout

\begin_deeper
\begin_layout Itemize
emacs day1.py &
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print "hello nurse!"
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
type
\end_layout

\begin_deeper
\begin_layout Itemize
C-x C-s
\end_layout

\end_deeper
\begin_layout Itemize
in terminal
\end_layout

\begin_deeper
\begin_layout Itemize
python day1.py
\end_layout

\end_deeper
\begin_layout Itemize
interpreted not compiled language
\end_layout

\begin_deeper
\begin_layout Itemize
interpreter runs it
\end_layout

\begin_layout Itemize
not compiled and then run
\end_layout

\end_deeper
\begin_layout Itemize
explain that they've just created their first program
\end_layout

\begin_layout Itemize
explain details as time permits
\end_layout

\begin_layout Itemize
talk about how python can do terminal or programs but we'll focus on programs
 to start
\end_layout

\begin_layout Subsection
Before they leave
\end_layout

\begin_layout Itemize
explain hw1-installation
\end_layout

\begin_deeper
\begin_layout Itemize
have them start it
\end_layout

\end_deeper
\begin_layout Itemize
on hw's @ for _at_
\end_layout

\begin_layout Itemize
show github...
\end_layout

\begin_layout Section
Beginning Python/how computers work
\end_layout

\begin_layout Subsection
Revisit first program
\end_layout

\begin_layout Itemize
open terminal
\end_layout

\begin_deeper
\begin_layout Itemize
mac is built on unix style system
\end_layout

\begin_layout Itemize
terminal gives you this access
\end_layout

\begin_layout Itemize
linux has it native
\end_layout

\begin_layout Itemize
windows must install it
\end_layout

\begin_layout Itemize
original way operating systems worked
\end_layout

\end_deeper
\begin_layout Itemize
basic unix
\end_layout

\begin_deeper
\begin_layout Itemize
show correspondance between unix view and point and click
\end_layout

\begin_layout Itemize
show basic commands
\end_layout

\begin_layout Itemize
show link to commands in webpage
\end_layout

\end_deeper
\begin_layout Itemize
text editor
\end_layout

\begin_deeper
\begin_layout Itemize
emacs day2.py &
\end_layout

\begin_deeper
\begin_layout Itemize
calls a unix program
\end_layout

\begin_layout Itemize
.py means a py file
\end_layout

\begin_layout Itemize
no spaces or special charaters
\end_layout

\begin_layout Itemize
& stops it from taking over window
\end_layout

\end_deeper
\begin_layout Itemize
explain what emacs does-edit text files
\end_layout

\begin_layout Itemize
they can use any they want, I prefer emacs
\end_layout

\begin_layout Itemize
show where commands can be found
\end_layout

\end_deeper
\begin_layout Itemize
explain code line by line
\end_layout

\begin_deeper
\begin_layout Itemize
comments
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#this is a comment after first line...
\end_layout

\begin_layout Plain Layout

print "hello nurse!" 
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
show them how to save
\end_layout

\begin_layout Itemize
in terminal
\end_layout

\begin_deeper
\begin_layout Itemize
python day2.py
\end_layout

\begin_deeper
\begin_layout Itemize
this calls interpreter
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Interpreter
\end_layout

\begin_layout Itemize
open interpreter by typing python (or kivy...)
\end_layout

\begin_layout Itemize
talk about what it does (allows you to test python code)
\end_layout

\begin_layout Itemize
show examples like
\end_layout

\begin_deeper
\begin_layout Itemize
1 + 3 + 6 / 2 (order of ops) 
\end_layout

\begin_layout Itemize
20 / 0 (errors) 
\end_layout

\begin_layout Itemize
3 / 2 (int math) 
\end_layout

\begin_layout Itemize
3 / 2.0 (double math)
\end_layout

\end_deeper
\begin_layout Subsection
Program 2
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

""" d1ex1.py
\end_layout

\begin_layout Plain Layout

A simple hello world program 
\end_layout

\begin_layout Plain Layout

"""
\end_layout

\begin_layout Plain Layout

# print a greeting 
\end_layout

\begin_layout Plain Layout

print "Hello World!" 
\end_layout

\begin_layout Plain Layout

print "Isn't it a wonderful day?!" 
\end_layout

\begin_layout Plain Layout

print "I can do math see!" 
\end_layout

\begin_layout Plain Layout

print "1 + 3 =", 1+3     # ',' let you join multiple things with a space
 
\end_layout

\begin_layout Plain Layout

print "2 * 8 =", 2*8 
\end_layout

\begin_layout Plain Layout

print "..." print "I guess I'll get going" print "goodbye"
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Commenting
\end_layout

\begin_layout Itemize
begin with # (equivalent to //)
\end_layout

\begin_layout Itemize
or between 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset


\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsection
Hit github again
\end_layout

\begin_layout Subsection
How computers work
\end_layout

\begin_layout Itemize
show off hardware
\end_layout

\begin_layout Itemize
explain basic architecture
\end_layout

\begin_deeper
\begin_layout Itemize
processor
\end_layout

\begin_layout Itemize
RAM
\end_layout

\begin_layout Itemize
etc
\end_layout

\end_deeper
\begin_layout Section
Data types and Variables chapter 2
\end_layout

\begin_layout Subsection
Datatypes
\end_layout

\begin_layout Itemize
Basic types 
\end_layout

\begin_deeper
\begin_layout Itemize
numbers 
\end_layout

\begin_layout Itemize
booleans 
\end_layout

\begin_layout Itemize
strings 
\end_layout

\end_deeper
\begin_layout Itemize
we will see others like lists, dictionaries, and objects later
\end_layout

\begin_layout Itemize
Integers
\end_layout

\begin_deeper
\begin_layout Itemize
positive/negative whole numbers 
\end_layout

\begin_layout Itemize
2, -3, 0 
\end_layout

\end_deeper
\begin_layout Itemize
Longs 
\end_layout

\begin_deeper
\begin_layout Itemize
really really big integers.
 
\end_layout

\begin_layout Itemize
1000000000000000000000000000000000000000000000000L 
\end_layout

\begin_layout Itemize
python should convert between these two types automatically if your integers
 get too big
\end_layout

\begin_layout Itemize
Longs end in a "L", don't worry about it if you see one
\end_layout

\end_deeper
\begin_layout Itemize
Floats
\end_layout

\begin_deeper
\begin_layout Itemize
A number with a decimal 
\end_layout

\begin_layout Itemize
3.5, -0.23 called floats because of floating decimal points
\end_layout

\begin_layout Itemize
_coders_ actually a double 
\end_layout

\begin_layout Itemize
can also be written in scientific notation -5.23E-4 
\end_layout

\end_deeper
\begin_layout Itemize
Booleans
\end_layout

\begin_deeper
\begin_layout Itemize
True or False
\end_layout

\end_deeper
\begin_layout Subsection
Variables
\end_layout

\begin_layout Itemize
variables are set to whatever appears to the right of =
\end_layout

\begin_layout Itemize
variable assignment
\end_layout

\begin_deeper
\begin_layout Itemize
message = "What’s up, Doc?"
\end_layout

\begin_layout Itemize
n = 17
\end_layout

\begin_layout Itemize
pi = 3.14159
\end_layout

\end_deeper
\begin_layout Itemize
single and double quotes do the same thing in python
\end_layout

\begin_deeper
\begin_layout Itemize
except when you want to inclose an apostrophy...
\end_layout

\end_deeper
\begin_layout Itemize
reserved words p.
 43 section 2.3
\end_layout

\begin_layout Itemize
how you store data
\end_layout

\begin_deeper
\begin_layout Itemize
talk about area set aside in memory
\end_layout

\end_deeper
\begin_layout Itemize
can't have
\end_layout

\begin_deeper
\begin_layout Itemize
spaces
\end_layout

\begin_layout Itemize
symbols
\end_layout

\begin_layout Itemize
start with numbers
\end_layout

\begin_layout Itemize
be reserved words
\end_layout

\end_deeper
\begin_layout Itemize
can have
\end_layout

\begin_deeper
\begin_layout Itemize
letters 
\end_layout

\begin_layout Itemize
numbers
\end_layout

\begin_layout Itemize
underscores
\end_layout

\end_deeper
\begin_layout Itemize
data types
\end_layout

\begin_deeper
\begin_layout Itemize
int
\end_layout

\begin_layout Itemize
float
\end_layout

\begin_layout Itemize
string
\end_layout

\end_deeper
\begin_layout Itemize
type command to determine data type
\end_layout

\begin_deeper
\begin_layout Itemize
type(3.2)
\end_layout

\end_deeper
\begin_layout Itemize
display using print
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bob="a string of text"
\end_layout

\begin_layout Plain Layout

number=5
\end_layout

\begin_layout Plain Layout

num2=6.5
\end_layout

\begin_layout Plain Layout

answer=number+num2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print bob
\end_layout

\begin_layout Plain Layout

print number
\end_layout

\begin_layout Plain Layout

print num2
\end_layout

\begin_layout Plain Layout

print answer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print type(bob)
\end_layout

\begin_layout Plain Layout

print type(number)
\end_layout

\begin_layout Plain Layout

print type(num2)
\end_layout

\begin_layout Plain Layout

print type(answer)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Arithmatic
\end_layout

\begin_layout Itemize
+
\end_layout

\begin_layout Itemize
-
\end_layout

\begin_layout Itemize
*
\end_layout

\begin_layout Itemize
/
\end_layout

\begin_layout Itemize
// integer division operation
\end_layout

\begin_layout Itemize
** (power, 2 to the 5th is 2**5)
\end_layout

\begin_layout Itemize
% modulo
\end_layout

\begin_layout Itemize
string operations
\end_layout

\begin_deeper
\begin_layout Itemize
+ concatinates
\end_layout

\begin_layout Itemize
* works if one is string and one integer (repeats the string integer times)
\end_layout

\end_deeper
\begin_layout Itemize
# to write comments
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

div1=6/5.0
\end_layout

\begin_layout Plain Layout

div2=6//5.0
\end_layout

\begin_layout Plain Layout

pow=2**8
\end_layout

\begin_layout Plain Layout

print "div1=",div1
\end_layout

\begin_layout Plain Layout

print "div2=",div2
\end_layout

\begin_layout Plain Layout

print "pow=",pow
\end_layout

\begin_layout Plain Layout

ans="huh "*5
\end_layout

\begin_layout Plain Layout

print "ans=",ans 
\end_layout

\begin_layout Plain Layout

mod=6%4
\end_layout

\begin_layout Plain Layout

print "mod=",mod
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Assignment operations
\end_layout

\begin_layout Itemize
+=
\end_layout

\begin_layout Itemize
-=
\end_layout

\begin_layout Itemize
*=
\end_layout

\begin_layout Itemize
/=
\end_layout

\begin_layout Itemize
%=
\end_layout

\begin_layout Subsection
Strings
\end_layout

\begin_layout Itemize
strings are a "sequence of characters" (best definition I could find)
\end_layout

\begin_deeper
\begin_layout Itemize
A character is a single letter, number, symbol like 'a', '4', '!', ' ',
 
\end_layout

\begin_layout Itemize
anything you can create with "one key press" 
\end_layout

\end_deeper
\begin_layout Itemize
Strings are immutable 
\end_layout

\begin_deeper
\begin_layout Itemize
once you create a string you cannot change it joining it with other strings
 
\end_layout

\begin_layout Itemize
taking off chunks simply creates new a string 
\end_layout

\end_deeper
\begin_layout Itemize
you can create using single or double quotes, though double are usually
 preferred
\end_layout

\begin_layout Subsection
Input
\end_layout

\begin_layout Itemize
keyboard input p.
 73
\end_layout

\begin_layout Itemize
input = raw_input ()
\end_layout

\begin_deeper
\begin_layout Itemize
name = raw_input ("What...is your name? ")
\end_layout

\begin_layout Itemize
input() //can be used to grab just an integer
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f=input("type a number")
\end_layout

\begin_layout Plain Layout

c=ftoc(f) 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
example 1
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print "Hello...I'm sorry, who are you?" 
\end_layout

\begin_layout Plain Layout

name = raw_input(name) 
\end_layout

\begin_layout Plain Layout

print "Hello, %s!" % name
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
example 2
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

n = raw_input("Enter a number:  ") 
\end_layout

\begin_layout Plain Layout

m = raw_input("Enter another:  ")
\end_layout

\begin_layout Plain Layout

n = int(n) m = int(m)
\end_layout

\begin_layout Plain Layout

print "%d+%d=%d" % (n,m,n+m) 
\end_layout

\begin_layout Plain Layout

print "%d-%d=%d" % (n,m,n-m) 
\end_layout

\begin_layout Plain Layout

print "%d*%d=%d" % (n,m,n*m) 
\end_layout

\begin_layout Plain Layout

print "%d/%d=%f" % (n,m,n/float(m))
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
example 3
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

s = " " 
\end_layout

\begin_layout Plain Layout

c = raw_input("What are the dyamind blocks?  ")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print 3*s, c 
\end_layout

\begin_layout Plain Layout

print 2*s, c*3 
\end_layout

\begin_layout Plain Layout

print 1*s, c*5 
\end_layout

\begin_layout Plain Layout

print 0*s, c*7 
\end_layout

\begin_layout Plain Layout

print 1*s, c*5 
\end_layout

\begin_layout Plain Layout

print 2*s, c*3 
\end_layout

\begin_layout Plain Layout

print 3*s, c
\end_layout

\end_inset


\end_layout

\begin_layout Section
If and While chapter 5 and 7
\end_layout

\begin_layout Subsection
Flow control
\end_layout

\begin_layout Itemize
control how to proceed though a program
\end_layout

\begin_layout Itemize
don't necessarily go in a linear manner
\end_layout

\begin_layout Subsection
conditionals chapter 5
\end_layout

\begin_layout Itemize
boolean expressions p.
 66
\end_layout

\begin_layout Itemize
==
\end_layout

\begin_deeper
\begin_layout Itemize
!=
\end_layout

\begin_layout Itemize
>
\end_layout

\begin_layout Itemize
< 
\end_layout

\begin_layout Itemize
>=
\end_layout

\begin_layout Itemize
<=
\end_layout

\end_deeper
\begin_layout Itemize
logical experessions p.66
\end_layout

\begin_deeper
\begin_layout Itemize
and
\end_layout

\begin_layout Itemize
or
\end_layout

\begin_layout Itemize
not
\end_layout

\end_deeper
\begin_layout Subsection
While loops chapter 7
\end_layout

\begin_layout Itemize
run while true
\end_layout

\begin_layout Itemize
for next example work through logic and flow on white board before doing
 code
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

c = 0 
\end_layout

\begin_layout Plain Layout

while c <= 0:     
\end_layout

\begin_layout Plain Layout

	c = raw_input("Countdown from?  ")     
\end_layout

\begin_layout Plain Layout

	c = int(c)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while c > 0:     
\end_layout

\begin_layout Plain Layout

	print "%d..." % c     
\end_layout

\begin_layout Plain Layout

	c -= 1     
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print "Blastoff!"
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
tabbing over is included in code
\end_layout

\begin_deeper
\begin_layout Itemize
not the {} of other languages
\end_layout

\begin_layout Itemize
for once formatting matters
\end_layout

\begin_layout Itemize
tab is bad (unless it just adds spaces.)
\end_layout

\end_deeper
\begin_layout Subsection
pygame introduction
\end_layout

\begin_layout Itemize
http://pygame.org/
\end_layout

\begin_layout Itemize
module that supplies stuff for games 
\end_layout

\begin_deeper
\begin_layout Itemize
like math module but for games
\end_layout

\end_deeper
\begin_layout Itemize
first example of it working
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import pygame
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#init pygame
\end_layout

\begin_layout Plain Layout

pygame.init()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#make a screen
\end_layout

\begin_layout Plain Layout

screen = pygame.display.set_mode((640, 480))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while True:
\end_layout

\begin_layout Plain Layout

    color=255,255,255
\end_layout

\begin_layout Plain Layout

    screen.fill(color)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
explain how code works
\end_layout

\begin_layout Itemize
use ctrl-c to kill processes that never end
\end_layout

\begin_layout Itemize
infinite loops-explain
\end_layout

\begin_layout Subsection
if chapter 5
\end_layout

\begin_layout Itemize
if p.67
\end_layout

\begin_layout Itemize
explain logic
\end_layout

\begin_layout Itemize
talk about how it changes flow
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

input = raw_input("> ")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if input=="Paul":
\end_layout

\begin_layout Plain Layout

	print "you are cool"
\end_layout

\begin_layout Plain Layout

elif input=="Alec" or input=="Jonah" or input=="Jack":
\end_layout

\begin_layout Plain Layout

	print "you smell bad"
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	print "you need some learnin"
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
now combine for a true game loop
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python                                                  
                                                                       
                      
\end_layout

\begin_layout Plain Layout

import pygame
\end_layout

\begin_layout Plain Layout

from pygame.locals import *
\end_layout

\begin_layout Plain Layout

# initialize pygame                                                    
                                                                       
                       
\end_layout

\begin_layout Plain Layout

pygame.init()
\end_layout

\begin_layout Plain Layout

# make a screen                                                        
                                                                       
                       
\end_layout

\begin_layout Plain Layout

screen = pygame.display.set_mode((640,480)) 
\end_layout

\begin_layout Plain Layout

done = False
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# while running                       
\end_layout

\begin_layout Plain Layout

while not done:     
\end_layout

\begin_layout Plain Layout

	event = pygame.event.poll()     
\end_layout

\begin_layout Plain Layout

	if event.type == QUIT:         
\end_layout

\begin_layout Plain Layout

		done = True     
\end_layout

\begin_layout Plain Layout

	elif event.type == KEYDOWN and event.key == K_ESCAPE:         
\end_layout

\begin_layout Plain Layout

		done = True
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print "quitting"
\end_layout

\end_inset


\end_layout

\begin_layout Section
For and lists
\end_layout

\begin_layout Subsection
Lists chapter 10
\end_layout

\begin_layout Itemize
mutable arrays
\end_layout

\begin_layout Itemize
can store multiple peices of data
\end_layout

\begin_layout Itemize
can store multiple kinds of data
\end_layout

\begin_layout Itemize
access like arrays
\end_layout

\begin_deeper
\begin_layout Itemize
bob[1]
\end_layout

\end_deeper
\begin_layout Itemize
len(list) works for lists too 
\end_layout

\begin_layout Itemize
search in list
\end_layout

\begin_deeper
\begin_layout Itemize
bob=['fred', 'jim']
\end_layout

\begin_layout Itemize
'fred' in bob (True)
\end_layout

\end_deeper
\begin_layout Itemize
+ concatinates lists together
\end_layout

\begin_layout Itemize
[:] work on lists like on strings p.
 116
\end_layout

\begin_layout Itemize
lists are mutable
\end_layout

\begin_deeper
\begin_layout Itemize
list = [’a’, ’d’, ’f’] 
\end_layout

\begin_layout Itemize
list[1:1] = [’b’, ’c’]
\end_layout

\begin_layout Itemize
print list 
\end_layout

\begin_deeper
\begin_layout Itemize
[’a’, ’b’, ’c’, ’d’, ’f’]
\end_layout

\end_deeper
\begin_layout Itemize
list[4:4] = [’e’] 
\end_layout

\begin_layout Itemize
print list 
\end_layout

\begin_deeper
\begin_layout Itemize
[’a’, ’b’, ’c’, ’d’, ’e’, ’f’]
\end_layout

\end_deeper
\begin_layout Itemize
delete with del
\end_layout

\begin_layout Itemize
del list[2:4] 
\end_layout

\begin_layout Itemize
print list
\end_layout

\begin_deeper
\begin_layout Itemize
['a', 'b', 'e', 'f']
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
python has 
\begin_inset Quotes eld
\end_inset

aliasing
\begin_inset Quotes erd
\end_inset

 p.
 120
\end_layout

\begin_deeper
\begin_layout Itemize
sorta like pointers
\end_layout

\begin_layout Itemize
doesn't alias everything...
\end_layout

\end_deeper
\begin_layout Itemize
list[-1]
\end_layout

\begin_deeper
\begin_layout Itemize
returns last element in list
\end_layout

\end_deeper
\begin_layout Itemize
to clone instead of alias a list
\end_layout

\begin_deeper
\begin_layout Itemize
b=a[:]
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

books=["title1",
\end_layout

\begin_layout Plain Layout

	"title2",
\end_layout

\begin_layout Plain Layout

	"title3"]
\end_layout

\begin_layout Plain Layout

books.append("title 5")
\end_layout

\begin_layout Plain Layout

print books
\end_layout

\begin_layout Plain Layout

print books[0]
\end_layout

\begin_layout Plain Layout

len(books)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
For
\end_layout

\begin_layout Itemize
loop through data, like a while loop
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for book in books:
\end_layout

\begin_layout Plain Layout

	print book,"is awesome"
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
In
\end_layout

\begin_layout Itemize
always variable in a list
\end_layout

\begin_layout Itemize
revisit previous
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

input = raw_input("type name> ")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

TAs=["Alec","Jack","Jonah"]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if input=="Paul":
\end_layout

\begin_layout Plain Layout

	print "you are cool"
\end_layout

\begin_layout Plain Layout

elif input in TAs:
\end_layout

\begin_layout Plain Layout

	print "you smell bad"
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	print "you need some learnin"
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
range
\end_layout

\begin_layout Itemize
can create a range p.
 111
\end_layout

\begin_layout Itemize
bob=range(1,5) 
\end_layout

\begin_deeper
\begin_layout Itemize
[1,2,3,4]
\end_layout

\begin_layout Itemize
range(1, 10, 2) 
\end_layout

\begin_layout Itemize
[1, 3, 5, 7, 9]
\end_layout

\begin_layout Itemize
empty=[]
\end_layout

\end_deeper
\begin_layout Subsection
for again
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for i in range(0,100):
\end_layout

\begin_layout Plain Layout

	print i
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Drawing lines
\end_layout

\begin_layout Itemize
pygame.draw.circle(place,color,point,radius,width)
\end_layout

\begin_layout Itemize
draw found at
\end_layout

\begin_deeper
\begin_layout Itemize
http://pygame.org/docs/ref/draw.html
\end_layout

\end_deeper
\begin_layout Subsection
examples
\end_layout

\begin_layout Subsubsection
basic lines and flip-give them this one, let them build the rest
\end_layout

\begin_layout Itemize
explain why line only goes to 399
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python
\end_layout

\begin_layout Plain Layout

"""
\end_layout

\begin_layout Plain Layout

draw1.py
\end_layout

\begin_layout Plain Layout

drawlines
\end_layout

\begin_layout Plain Layout

"""
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import pygame
\end_layout

\begin_layout Plain Layout

from pygame.locals import *
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pygame.init()
\end_layout

\begin_layout Plain Layout

screen = pygame.display.set_mode((400,400))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

done = False
\end_layout

\begin_layout Plain Layout

bg = (0,0,0)
\end_layout

\begin_layout Plain Layout

fg = (255,0,0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while not done:
\end_layout

\begin_layout Plain Layout

    for event in pygame.event.get():
\end_layout

\begin_layout Plain Layout

        if event.type == QUIT:
\end_layout

\begin_layout Plain Layout

            done = True
\end_layout

\begin_layout Plain Layout

        elif event.type == KEYDOWN and event.key == K_ESCAPE:
\end_layout

\begin_layout Plain Layout

            done = True
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       # draw
\end_layout

\begin_layout Plain Layout

        screen.fill(bg)
\end_layout

\begin_layout Plain Layout

        for i in range(400):
\end_layout

\begin_layout Plain Layout

            pygame.draw.line(screen, fg, (0,i), (i,399))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       # refresh
\end_layout

\begin_layout Plain Layout

        pygame.display.flip()
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

print "ByeBye" 
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
explain flip
\end_layout

\begin_layout Subsubsection
now separate lines
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for i in range(0,400,8)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
draw in all corners
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pygame.draw.line(screen, fg, (0,i), (i,399))             
\end_layout

\begin_layout Plain Layout

pygame.draw.line(screen, fg, (0,i), (399-i,0))             
\end_layout

\begin_layout Plain Layout

pygame.draw.line(screen, fg, (i,0), (399,i))             
\end_layout

\begin_layout Plain Layout

pygame.draw.line(screen, fg, (i,399), (399,399-i))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
user controls separation
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#before while loop
\end_layout

\begin_layout Plain Layout

minstep = 1 
\end_layout

\begin_layout Plain Layout

maxstep = 200
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#in while loop
\end_layout

\begin_layout Plain Layout

elif event.type == KEYDOWN and event.key == K_UP:
\end_layout

\begin_layout Plain Layout

	step = max(minstep, step-1)
\end_layout

\begin_layout Plain Layout

elif event.type == KEYDOWN and event.key == K_DOWN:
\end_layout

\begin_layout Plain Layout

	step = min(maxstep, step+1)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
now handle holding down keys
\end_layout

\begin_layout Itemize
repeatedly send key command 
\end_layout

\begin_deeper
\begin_layout Itemize
allows you to hold down key
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pygame.key.set_repeat(100,100)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Code formatting
\end_layout

\begin_layout Itemize
documentation
\end_layout

\begin_deeper
\begin_layout Itemize
help()
\end_layout

\begin_deeper
\begin_layout Itemize
returns comment string at top
\end_layout

\end_deeper
\begin_layout Itemize
dir()
\end_layout

\begin_deeper
\begin_layout Itemize
returns all of the functions from inside the file
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
web searches
\end_layout

\begin_deeper
\begin_layout Itemize
pygame doc
\end_layout

\begin_layout Itemize
python doc
\end_layout

\end_deeper
\begin_layout Itemize
filtering examples:
\end_layout

\begin_deeper
\begin_layout Itemize
do a web search for a specific thing we want to do
\end_layout

\begin_layout Itemize
filter the examples for what's good and bad
\end_layout

\begin_layout Itemize
always look at more then 1 example
\end_layout

\end_deeper
\begin_layout Itemize
talk about good formatting of code
\end_layout

\begin_deeper
\begin_layout Itemize
comment block at top
\end_layout

\begin_deeper
\begin_layout Itemize
this is what help returns
\end_layout

\end_deeper
\begin_layout Itemize
variable naming
\end_layout

\begin_deeper
\begin_layout Itemize
if it's important then give it a name that's representative
\end_layout

\begin_layout Itemize
conventions
\end_layout

\begin_deeper
\begin_layout Itemize
all caps CONSTANT
\end_layout

\begin_layout Itemize
first letter capital is Object
\end_layout

\begin_layout Itemize
long names
\end_layout

\begin_deeper
\begin_layout Itemize
camelCaps
\end_layout

\begin_deeper
\begin_layout Itemize
use this
\end_layout

\end_deeper
\begin_layout Itemize
under_Score
\end_layout

\begin_layout Itemize
nothingbetween
\end_layout

\end_deeper
\begin_layout Itemize
__len__ 
\end_layout

\begin_deeper
\begin_layout Itemize
special variables
\end_layout

\begin_layout Itemize
python has defined
\end_layout

\end_deeper
\begin_layout Itemize
_x 
\end_layout

\begin_deeper
\begin_layout Itemize
considered private
\end_layout

\begin_layout Itemize
not actually private
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Itemize
commenting
\end_layout

\begin_deeper
\begin_layout Itemize
#comment
\end_layout

\begin_layout Itemize
multiline comments 
\end_layout

\begin_deeper
\begin_layout Itemize
just create a multiline string 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset


\begin_inset Quotes erd
\end_inset

 or ''' at start and end of comment
\end_layout

\begin_layout Itemize
more conventional to use # at start of first line
\end_layout

\end_deeper
\begin_layout Itemize
should put a comment around everything that is not obvious
\end_layout

\begin_layout Itemize
long comments on line before code
\end_layout

\begin_layout Itemize
talk about what variable is used for
\end_layout

\begin_layout Itemize
describe how functions work
\end_layout

\end_deeper
\begin_layout Itemize
spacing
\end_layout

\begin_deeper
\begin_layout Itemize
use spaces to separate different ideas
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
examples
\end_layout

\begin_layout Itemize
bad code
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

bad
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
work towards
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

good
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
give them the following to clean up on their own
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

bad 2
\end_layout

\end_inset


\end_layout

\begin_layout Section
Debugging
\end_layout

\begin_layout Itemize
how to fix your shit without outside help
\end_layout

\begin_layout Itemize
describe how we learned to debug
\end_layout

\begin_deeper
\begin_layout Itemize
Alec wanted to build a program and had no one to ask for help
\end_layout

\begin_layout Itemize
Jonah was working on a final project at 3am and Lee wasn't available by
 phone
\end_layout

\begin_layout Itemize
Jack was doing something complicated and no one to ask
\end_layout

\begin_layout Itemize
Paul had a professor who made him do it line by line
\end_layout

\end_deeper
\begin_layout Itemize
you learn to debug by doing it
\end_layout

\begin_layout Subsection
Programming errors
\end_layout

\begin_layout Itemize
types
\end_layout

\begin_deeper
\begin_layout Itemize
indentation errors
\end_layout

\begin_layout Itemize
syntax errors
\end_layout

\begin_layout Itemize
everytihng is a typo
\end_layout

\begin_layout Itemize
variable not defined
\end_layout

\end_deeper
\begin_layout Itemize
python shows you where the error is, usually
\end_layout

\begin_deeper
\begin_layout Itemize
if not look above
\end_layout

\begin_layout Itemize
it should be near by
\end_layout

\end_deeper
\begin_layout Itemize
the biggest thing is figureing out exactly where the error is
\end_layout

\begin_layout Itemize
you'll do this on the homework
\end_layout

\begin_layout Subsection
Algorithmic errors
\end_layout

\begin_layout Itemize
it runs but does the wrong thing
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

wife asks her husband to go the the store and pick up a loaf of bread and
 if they have eggs to pick up a dozen
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

husband returns with a dozen loaves of bread
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
the instructions were wrong
\end_layout

\begin_layout Itemize
computers are stupid and have no common sense
\end_layout

\end_deeper
\begin_layout Itemize
print out all variable values to check them
\end_layout

\begin_layout Itemize
manually run through what they expect the code to be doing at each step
\end_layout

\begin_deeper
\begin_layout Itemize
act out the compiler
\end_layout

\end_deeper
\begin_layout Itemize
print statements
\end_layout

\begin_layout Itemize
you can use raw_input() as a way to pause a program part way through running
\end_layout

\begin_layout Section
Functions chapter 3
\end_layout

\begin_layout Itemize
prebuilt functions
\end_layout

\begin_deeper
\begin_layout Itemize
raw_input()
\end_layout

\begin_layout Itemize
type()
\end_layout

\begin_deeper
\begin_layout Itemize
returns type of variable
\end_layout

\end_deeper
\begin_layout Itemize
int()
\end_layout

\begin_deeper
\begin_layout Itemize
pulls the integer out of a string 
\end_layout

\begin_layout Itemize
converts floating-point values to integers
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

str1="5"
\end_layout

\begin_layout Plain Layout

str2="7"
\end_layout

\begin_layout Plain Layout

str3=str1+str2
\end_layout

\begin_layout Plain Layout

print str3
\end_layout

\begin_layout Plain Layout

str1=int(str1)
\end_layout

\begin_layout Plain Layout

str2=int(str2)
\end_layout

\begin_layout Plain Layout

str3=str1+str2
\end_layout

\begin_layout Plain Layout

print str3 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
float()
\end_layout

\begin_deeper
\begin_layout Itemize
equivelant to int() but for floats
\end_layout

\end_deeper
\begin_layout Itemize
str()
\end_layout

\begin_deeper
\begin_layout Itemize
converts to string
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
python automatically converts to float if either operator is a float
\end_layout

\begin_layout Itemize
functions defined as follows
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def NAME( LIST OF PARAMETERS ): 
\end_layout

\begin_layout Plain Layout

	STATEMENTS
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def printStuff(arg1, bob):
\end_layout

\begin_layout Plain Layout

	print arg1
\end_layout

\begin_layout Plain Layout

	print bob
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
variables defined within functions are local
\end_layout

\begin_layout Subsection
examples
\end_layout

\begin_layout Subsubsection
draw tie fighter in upper left corner
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python
\end_layout

\begin_layout Plain Layout

"""
\end_layout

\begin_layout Plain Layout

tie1.py
\end_layout

\begin_layout Plain Layout

draws a tie fighter in the upper corner of the screen
\end_layout

\begin_layout Plain Layout

"""
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import pygame
\end_layout

\begin_layout Plain Layout

from pygame import draw
\end_layout

\begin_layout Plain Layout

from pygame.locals import *
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pygame.init()
\end_layout

\begin_layout Plain Layout

screen = pygame.display.set_mode((800,600))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

screen.fill((0,0,0))
\end_layout

\begin_layout Plain Layout

done = False
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while not done:
\end_layout

\begin_layout Plain Layout

    for event in pygame.event.get():
\end_layout

\begin_layout Plain Layout

        if event.type == QUIT:
\end_layout

\begin_layout Plain Layout

            done = True
\end_layout

\begin_layout Plain Layout

        elif event.type == KEYDOWN and event.key == K_ESCAPE:
\end_layout

\begin_layout Plain Layout

            done = True
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   # draw tie fighter
\end_layout

\begin_layout Plain Layout

    draw.rect(screen, (255,0,0), (0,0,5,40))
\end_layout

\begin_layout Plain Layout

    draw.rect(screen, (255,0,0), (35,0,5,40))
\end_layout

\begin_layout Plain Layout

    draw.rect(screen, (255,0,0), (0,17,40,5))
\end_layout

\begin_layout Plain Layout

    draw.circle(screen, (255,0,0), (20,20), 10)
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    pygame.display.flip()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print "ByeBye"
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
now do same thing but with function
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python
\end_layout

\begin_layout Plain Layout

"""
\end_layout

\begin_layout Plain Layout

tie2.py
\end_layout

\begin_layout Plain Layout

draws a tie fighter in the upper corner of the screen with func
\end_layout

\begin_layout Plain Layout

"""
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import pygame
\end_layout

\begin_layout Plain Layout

from pygame import draw
\end_layout

\begin_layout Plain Layout

from pygame.locals import *
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pygame.init()
\end_layout

\begin_layout Plain Layout

screen = pygame.display.set_mode((800,600))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

screen.fill((0,0,0))
\end_layout

\begin_layout Plain Layout

done = False
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def draw_tie(surf, color):
\end_layout

\begin_layout Plain Layout

    draw.rect(surf, color, (0,0,5,40))
\end_layout

\begin_layout Plain Layout

    draw.rect(surf, color, (35,0,5,40))
\end_layout

\begin_layout Plain Layout

    draw.rect(surf, color, (0,17,40,5))
\end_layout

\begin_layout Plain Layout

    draw.circle(surf, color, (20,20), 10)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while not done:
\end_layout

\begin_layout Plain Layout

    for event in pygame.event.get():
\end_layout

\begin_layout Plain Layout

        if event.type == QUIT:
\end_layout

\begin_layout Plain Layout

            done = True
\end_layout

\begin_layout Plain Layout

        elif event.type == KEYDOWN and event.key == K_ESCAPE:
\end_layout

\begin_layout Plain Layout

            done = True
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   # draw tie fighter
\end_layout

\begin_layout Plain Layout

    draw_tie(screen, (255,0,0))
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    pygame.display.flip()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print "ByeBye"
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
now get them do draw multiple tie fighters
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# draw tie fighter     
\end_layout

\begin_layout Plain Layout

draw_tie(screen, (255,0,0), (20, 200))     
\end_layout

\begin_layout Plain Layout

draw_tie(screen, (255,128,255), (0, 0))     
\end_layout

\begin_layout Plain Layout

draw_tie(screen, (255,255,0), (300, 400))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
now draw where you click
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#function
\end_layout

\begin_layout Plain Layout

def draw_tie(surf, color, pos):
\end_layout

\begin_layout Plain Layout

    x,y = pos
\end_layout

\begin_layout Plain Layout

    draw.rect(surf, color, (x,y,5,40))
\end_layout

\begin_layout Plain Layout

    draw.rect(surf, color, (x+35,y,5,40))
\end_layout

\begin_layout Plain Layout

    draw.rect(surf, color, (x,y+17,40,5))
\end_layout

\begin_layout Plain Layout

    draw.circle(surf, color, (x+20,y+20), 10)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#in code
\end_layout

\begin_layout Plain Layout

	elif event.type == MOUSEBUTTONDOWN:
\end_layout

\begin_layout Plain Layout

		draw_tie(screen, (255,0,0), pygame.mouse.get_pos())
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
examples for them to try
\end_layout

\begin_layout Subsubsection
have them change the size of tie fighters
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def draw_tie(surf, pos, color=(255,0,0), size=40):
\end_layout

\begin_layout Plain Layout

    "Draws a tie fighter"
\end_layout

\begin_layout Plain Layout

    x,y = pos
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    wall = size/8
\end_layout

\begin_layout Plain Layout

    x0,x1 = x - (size/2), x + (size/2)
\end_layout

\begin_layout Plain Layout

    y0,y1 = y - (size/2), y + (size/2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    draw.rect(surf, color, (x0, y0, wall, size))
\end_layout

\begin_layout Plain Layout

    draw.rect(surf, color, (x1-wall, y0, wall, size))
\end_layout

\begin_layout Plain Layout

    draw.rect(surf, color, (x0, y-(wall/2), size, wall))
\end_layout

\begin_layout Plain Layout

    draw.circle(surf, color, (x, y), size/4) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#call with
\end_layout

\begin_layout Plain Layout

draw_tie(screen, pygame.mouse.get_pos(), size=80)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
talk about default values to functions
\end_layout

\begin_layout Subsubsection
now draw random size and color
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

elif event.type == MOUSEBUTTONDOWN:             
\end_layout

\begin_layout Plain Layout

	pos = pygame.mouse.get_pos()             
\end_layout

\begin_layout Plain Layout

	color = (randrange(100,256), randrange(100,256), randrange(100,256))  
           
\end_layout

\begin_layout Plain Layout

	size = randrange(30,80)             
\end_layout

\begin_layout Plain Layout

	draw_tie(screen, pos, color, size)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
now same thing but with redrawing the background 
\end_layout

\begin_layout Itemize
(talk about redrawing background)
\end_layout

\begin_layout Itemize
screen redraw every time through the loop
\end_layout

\begin_layout Itemize
use a list
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

elif event.type == MOUSEBUTTONDOWN:
\end_layout

\begin_layout Plain Layout

	pos = pygame.mouse.get_pos()
\end_layout

\begin_layout Plain Layout

	color = (randrange(100,256), randrange(100,256), randrange(100,256))
\end_layout

\begin_layout Plain Layout

	size = randrange(30,80)
\end_layout

\begin_layout Plain Layout

	ties.append((pos,color,size))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# draw
\end_layout

\begin_layout Plain Layout

screen.fill((0,0,0))
\end_layout

\begin_layout Plain Layout

for tie in ties:
\end_layout

\begin_layout Plain Layout

	pos,color,size = tie
\end_layout

\begin_layout Plain Layout

	draw_tie(screen, pos, color, size) 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
now have tie fighters shrink
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

        elif event.type == MOUSEBUTTONDOWN:
\end_layout

\begin_layout Plain Layout

            pos = pygame.mouse.get_pos()
\end_layout

\begin_layout Plain Layout

            color = (randrange(100,256), randrange(100,256), randrange(100,256))
\end_layout

\begin_layout Plain Layout

            size = 80
\end_layout

\begin_layout Plain Layout

            ties.append([pos,color,size])
\end_layout

\begin_layout Plain Layout

    # update
\end_layout

\begin_layout Plain Layout

    # not crazy about this, but list comps are complicated
\end_layout

\begin_layout Plain Layout

    for i in range(len(ties)-1, -1, -1):
\end_layout

\begin_layout Plain Layout

        tie = ties[i]
\end_layout

\begin_layout Plain Layout

        tie[2] -= 2
\end_layout

\begin_layout Plain Layout

        if tie[2] <= 0:
\end_layout

\begin_layout Plain Layout

            ties.pop(i)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
now full solution but cleaner
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python
\end_layout

\begin_layout Plain Layout

"""
\end_layout

\begin_layout Plain Layout

tie9.py
\end_layout

\begin_layout Plain Layout

tie fighters now shrink.
  A bit cleaner
\end_layout

\begin_layout Plain Layout

"""
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

from random import randrange
\end_layout

\begin_layout Plain Layout

import pygame
\end_layout

\begin_layout Plain Layout

from pygame import draw
\end_layout

\begin_layout Plain Layout

from pygame.locals import *
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def draw_tie(surf, pos, color=(255,0,0), size=40):
\end_layout

\begin_layout Plain Layout

    "Draws a tie fighter"
\end_layout

\begin_layout Plain Layout

    x,y = pos
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    wall = size/8
\end_layout

\begin_layout Plain Layout

    x0,x1 = x - (size/2), x + (size/2)
\end_layout

\begin_layout Plain Layout

    y0,y1 = y - (size/2), y + (size/2)
\end_layout

\begin_layout Plain Layout

    draw.rect(surf, color, (x0, y0, wall, size))
\end_layout

\begin_layout Plain Layout

    draw.rect(surf, color, (x1-wall, y0, wall, size))
\end_layout

\begin_layout Plain Layout

    draw.rect(surf, color, (x0, y-(wall/2), size, wall))
\end_layout

\begin_layout Plain Layout

    draw.circle(surf, color, (x, y), size/4)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ties = []
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def create_tie():
\end_layout

\begin_layout Plain Layout

    pos = pygame.mouse.get_pos()
\end_layout

\begin_layout Plain Layout

    color = (randrange(100,256), randrange(100,256), randrange(100,256))
\end_layout

\begin_layout Plain Layout

    size = 80
\end_layout

\begin_layout Plain Layout

    ties.append([pos,color,size])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def update():
\end_layout

\begin_layout Plain Layout

    # not crazy about this, but list comps are complicated
\end_layout

\begin_layout Plain Layout

    # how to actually do this with list comp is
\end_layout

\begin_layout Plain Layout

    # ties = [ (pos,color,size-2) for pos,color,size in ties if size > 0
 ]
\end_layout

\begin_layout Plain Layout

    for i in range(len(ties)-1, -1, -1):
\end_layout

\begin_layout Plain Layout

        tie = ties[i]
\end_layout

\begin_layout Plain Layout

        tie[2] -= 2
\end_layout

\begin_layout Plain Layout

        if tie[2] <= 0:
\end_layout

\begin_layout Plain Layout

            ties.pop(i)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pygame.init()
\end_layout

\begin_layout Plain Layout

screen = pygame.display.set_mode((800,600))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ties = []
\end_layout

\begin_layout Plain Layout

done = False
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while not done:
\end_layout

\begin_layout Plain Layout

    for event in pygame.event.get():
\end_layout

\begin_layout Plain Layout

        if event.type == QUIT:
\end_layout

\begin_layout Plain Layout

            done = True
\end_layout

\begin_layout Plain Layout

        elif event.type == KEYDOWN and event.key == K_ESCAPE:
\end_layout

\begin_layout Plain Layout

            done = True
\end_layout

\begin_layout Plain Layout

        elif event.type == MOUSEBUTTONDOWN:
\end_layout

\begin_layout Plain Layout

            create_tie()
\end_layout

\begin_layout Plain Layout

    update()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   # draw
\end_layout

\begin_layout Plain Layout

    screen.fill((0,0,0))
\end_layout

\begin_layout Plain Layout

    for pos,color,size in ties:
\end_layout

\begin_layout Plain Layout

        draw_tie(screen, pos, color, size)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    pygame.display.flip()
\end_layout

\begin_layout Plain Layout

    pygame.time.wait(50)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print "ByeBye"
\end_layout

\end_inset


\end_layout

\begin_layout Section
Functions with return
\end_layout

\begin_layout Subsection
modules
\end_layout

\begin_layout Itemize
python uses modules instead of libraries
\end_layout

\begin_layout Itemize
import math
\end_layout

\begin_deeper
\begin_layout Itemize
then use parts of it with dot notation
\end_layout

\begin_deeper
\begin_layout Itemize
math.sin()
\end_layout

\begin_layout Itemize
math.sin(math.pi)
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
indents instead of {}
\end_layout

\begin_layout Itemize
random
\end_layout

\begin_layout Itemize
differences between import and import from
\end_layout

\begin_layout Subsection
return
\end_layout

\begin_layout Itemize
return statements p.70
\end_layout

\begin_deeper
\begin_layout Itemize
used to end a function early, it will end when return is seen
\end_layout

\begin_layout Itemize
doesn't need to be given any value
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def ftoc(temp):
\end_layout

\begin_layout Plain Layout

    cent=temp-32
\end_layout

\begin_layout Plain Layout

    cent*=5
\end_layout

\begin_layout Plain Layout

    cent/=9
\end_layout

\begin_layout Plain Layout

    return cent
\end_layout

\begin_layout Plain Layout

c=ftoc(95)
\end_layout

\begin_layout Plain Layout

print "temp in C is ",c 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
examples
\end_layout

\begin_layout Section
Advanced data structures
\end_layout

\begin_layout Subsection
multi-dimensional lists (lists in lists)
\end_layout

\begin_layout Itemize
lists within lists
\end_layout

\begin_layout Itemize
list = ["hello", 2.0, 5, [10, 20]]
\end_layout

\begin_deeper
\begin_layout Itemize
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
\end_layout

\begin_layout Itemize
access with list[3][1]
\end_layout

\end_deeper
\begin_layout Subsection
Tuples chapter 12
\end_layout

\begin_layout Itemize
immutable
\end_layout

\begin_layout Itemize
fast
\end_layout

\begin_layout Itemize
point=(1,2)
\end_layout

\begin_layout Itemize
color=(255,255,255)
\end_layout

\begin_deeper
\begin_layout Itemize
talk about colors
\end_layout

\begin_layout Itemize
0-255 for each
\end_layout

\begin_layout Itemize
explain 24 bit color
\end_layout

\end_deeper
\begin_layout Itemize
color=(255,255,255,255)
\end_layout

\begin_deeper
\begin_layout Itemize
RGBA also exists
\end_layout

\end_deeper
\begin_layout Subsection
dictionaries chapter 11
\end_layout

\begin_layout Itemize
key value pair
\end_layout

\begin_deeper
\begin_layout Itemize
map names to data
\end_layout

\begin_layout Itemize
order doesn't matter
\end_layout

\begin_layout Itemize
used a lot on the web
\end_layout

\begin_deeper
\begin_layout Itemize
can do stuff like product name to data
\end_layout

\begin_layout Itemize
fetching data sent to a server
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
dictionaries allow you to index off something other then numbers
\end_layout

\begin_deeper
\begin_layout Itemize
way 1
\end_layout

\begin_deeper
\begin_layout Itemize
eng2sp = {}
\end_layout

\begin_layout Itemize
eng2sp[’one’] = ’uno’ 
\end_layout

\begin_layout Itemize
eng2sp[’two’] = ’dos’
\end_layout

\end_deeper
\begin_layout Itemize
way 2
\end_layout

\begin_deeper
\begin_layout Itemize
eng2sp = {’one’: ’uno’, ’two’: ’dos’, ’three’: ’tres’}
\end_layout

\end_deeper
\begin_layout Itemize
though numbers can still be used
\end_layout

\begin_deeper
\begin_layout Itemize
num2eng = {1: 
\begin_inset Quotes eld
\end_inset

one
\begin_inset Quotes erd
\end_inset

, 2: 
\begin_inset Quotes eld
\end_inset

two
\begin_inset Quotes erd
\end_inset

 }
\end_layout

\end_deeper
\begin_layout Itemize
or any other python object
\end_layout

\end_deeper
\begin_layout Itemize
can still delete elements of dictionaries with del()
\end_layout

\begin_deeper
\begin_layout Itemize
del eng2sp['one']
\end_layout

\end_deeper
\begin_layout Itemize
len() also still works
\end_layout

\begin_layout Itemize
dictionaries are mutable
\end_layout

\begin_layout Itemize
can return keys and values
\end_layout

\begin_deeper
\begin_layout Itemize
eng2sp.keys()
\end_layout

\begin_layout Itemize
eng2sp.values()
\end_layout

\begin_layout Itemize
eng2sp.items()
\end_layout

\end_deeper
\begin_layout Itemize
dictionaries alias p.
 138
\end_layout

\begin_deeper
\begin_layout Itemize
to copy:
\end_layout

\begin_layout Itemize
copy=eng2sp.copy()
\end_layout

\end_deeper
\begin_layout Standard
Dictionary example of insulting TAS from dictionary
\end_layout

\begin_layout Standard
NOTE: might want another example
\end_layout

\begin_layout Subsection
string chapter 8 p.
 71
\end_layout

\begin_layout Itemize
split
\end_layout

\begin_layout Itemize
strip
\end_layout

\begin_layout Itemize
upper and lower
\end_layout

\begin_layout Itemize
be sure to show them where to find stuff
\end_layout

\begin_deeper
\begin_layout Itemize
search 
\begin_inset Quotes eld
\end_inset

string python
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
http://docs.python.org/library/string.html
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

 >>> s = 'Monty Python' 
\end_layout

\begin_layout Plain Layout

>>> print s[0:5] 
\end_layout

\begin_layout Plain Layout

Monty 
\end_layout

\begin_layout Plain Layout

>>> print s[6:12] 
\end_layout

\begin_layout Plain Layout

Pytho
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
examples
\end_layout

\begin_layout Section
Using Objects
\end_layout

\begin_layout Itemize
Objects
\end_layout

\begin_deeper
\begin_layout Itemize
contain data (attributes)
\end_layout

\begin_layout Itemize
contain functions that run on data (methods)
\end_layout

\begin_layout Itemize
instance (object in use)
\end_layout

\end_deeper
\begin_layout Itemize
they are a great way of organizing code
\end_layout

\begin_deeper
\begin_layout Itemize
they group data with what uses it
\end_layout

\begin_layout Itemize
make code cleaner
\end_layout

\end_deeper
\begin_layout Itemize
describe using the Penn State example
\end_layout

\begin_deeper
\begin_layout Itemize
case of beer class
\end_layout

\begin_layout Itemize
has attributes (beers in case)
\end_layout

\begin_layout Itemize
method (remove beer)
\end_layout

\begin_layout Itemize
specific instance (that case of dogfish head)
\end_layout

\end_deeper
\begin_layout Itemize
pygame objects
\end_layout

\begin_deeper
\begin_layout Itemize
we've been using them since pygame has them
\end_layout

\end_deeper
\begin_layout Itemize
we've been useing existing objects
\end_layout

\begin_deeper
\begin_layout Itemize
surface 
\end_layout

\begin_layout Itemize
rect
\end_layout

\begin_layout Itemize
clamp
\end_layout

\begin_layout Itemize
bouncing ball
\end_layout

\begin_layout Itemize
player at mouse
\end_layout

\begin_layout Itemize
collision
\end_layout

\end_deeper
\begin_layout Subsection
examples
\end_layout

\begin_layout Section
create our own objects
\end_layout

\begin_layout Enumerate
group data and logic
\end_layout

\begin_deeper
\begin_layout Enumerate
everything has an update and draw
\end_layout

\begin_layout Enumerate
recreate previous day, but cooler
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Point: 
\end_layout

\begin_layout Plain Layout

	pass
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

blank = Point()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

blank.x = 3.0
\end_layout

\begin_layout Plain Layout

blank.y = 4.0
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
functions that run on classes
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def printPoint(p): 
\end_layout

\begin_layout Plain Layout

	print ’(’ + str(p.x) + ’, ’ + str(p.y) + ’)’
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
is
\end_layout

\begin_deeper
\begin_layout Itemize
check to see if to variables point to the same thing
\end_layout

\begin_layout Itemize
doesn't check if classes are equal
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> p2 = p1 
\end_layout

\begin_layout Plain Layout

>>> p1 is p2 
\end_layout

\begin_layout Plain Layout

True
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Rectangle: 
\end_layout

\begin_layout Plain Layout

	pass 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

box = Rectangle() 
\end_layout

\begin_layout Plain Layout

box.width = 100.0 
\end_layout

\begin_layout Plain Layout

box.height = 200.0 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

box.corner = Point() 
\end_layout

\begin_layout Plain Layout

box.corner.x = 0.0 
\end_layout

\begin_layout Plain Layout

box.corner.y = 0.0
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
copy module that allows you to copy anything
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import copy 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

p1 = Point() 
\end_layout

\begin_layout Plain Layout

p1.x = 3 
\end_layout

\begin_layout Plain Layout

p1.y = 4 
\end_layout

\begin_layout Plain Layout

p2 = copy.copy(p1)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
copy.copy() 
\end_layout

\begin_deeper
\begin_layout Itemize
only copies the top level and creates aliases below top level
\end_layout

\end_deeper
\begin_layout Itemize
copy.deepcopy()
\end_layout

\begin_deeper
\begin_layout Itemize
copes all levels of objects
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
inheritance (*can inherit from multiple, very messy)
\end_layout

\begin_deeper
\begin_layout Enumerate
inherit from existing
\end_layout

\begin_deeper
\begin_layout Enumerate
again rebuild
\end_layout

\begin_layout Enumerate
inherit from standard bad guy, etc
\end_layout

\begin_layout Enumerate
extend sprite
\end_layout

\end_deeper
\begin_layout Enumerate
inherit from created
\end_layout

\begin_layout Enumerate
introduce sprite group
\end_layout

\end_deeper
\begin_layout Section*
Chapter 13 classes and functions
\end_layout

\begin_layout Itemize
python allows both
\end_layout

\begin_deeper
\begin_layout Itemize
functions
\end_layout

\begin_deeper
\begin_layout Itemize
take arguments and don't change the inputs
\end_layout

\end_deeper
\begin_layout Itemize
modifiers
\end_layout

\begin_deeper
\begin_layout Itemize
change the inputs to a function
\end_layout

\end_deeper
\end_deeper
\begin_layout Section*
Chapter 14 classes and methods
\end_layout

\begin_layout Itemize
method definition
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Time: 
\end_layout

\begin_layout Plain Layout

	def printTime(time): 
\end_layout

\begin_layout Plain Layout

		print str(time.hours) + ":" + 
\backslash
 
\end_layout

\begin_layout Plain Layout

			str(time.minutes) + ":" + 
\backslash
 
\end_layout

\begin_layout Plain Layout

			str(time.seconds)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

currentTime.printTime();
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Time: 
\end_layout

\begin_layout Plain Layout

	#previous method definitions here...
 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def increment(self, seconds): 
\end_layout

\begin_layout Plain Layout

		self.seconds = seconds + self.seconds 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		while self.seconds >= 60: 
\end_layout

\begin_layout Plain Layout

			self.seconds = self.seconds - 60
\end_layout

\begin_layout Plain Layout

			self.minutes = self.minutes + 1 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		while self.minutes >= 60: 
\end_layout

\begin_layout Plain Layout

			self.minutes = self.minutes - 60 
\end_layout

\begin_layout Plain Layout

			self.hours = self.hours + 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

currentTime.increment(500)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
methods use a funky definition
\end_layout

\begin_deeper
\begin_layout Itemize
they pass themselves (or what they want the object to be refereed to) in
 the definition
\end_layout

\end_deeper
\begin_layout Itemize
can have methods that take variable argument lists by setting defaults
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def find(str, ch, start=0): 
\end_layout

\begin_layout Plain Layout

	index = start 
\end_layout

\begin_layout Plain Layout

	while index < len(str): 
\end_layout

\begin_layout Plain Layout

		if str[index] == ch: 
\end_layout

\begin_layout Plain Layout

			return index 
\end_layout

\begin_layout Plain Layout

		index = index + 1 
\end_layout

\begin_layout Plain Layout

	return -1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

find("apple", "p")
\end_layout

\begin_layout Plain Layout

find("apple", "p", 2)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
initialization method
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Time: 
\end_layout

\begin_layout Plain Layout

	def __init__(self, hours=0, minutes=0, seconds=0): 
\end_layout

\begin_layout Plain Layout

		self.hours = hours 
\end_layout

\begin_layout Plain Layout

		self.minutes = minutes 
\end_layout

\begin_layout Plain Layout

		self.seconds = seconds
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> currentTime = Time(9, 14, 30) 
\end_layout

\begin_layout Plain Layout

>>> currentTime.printTime() 
\end_layout

\begin_layout Plain Layout

9:14:30
\end_layout

\begin_layout Plain Layout

>>> currentTime = Time() 
\end_layout

\begin_layout Plain Layout

>>> currentTime.printTime() 
\end_layout

\begin_layout Plain Layout

0:0:0
\end_layout

\begin_layout Plain Layout

>>> currentTime = Time (9) 
\end_layout

\begin_layout Plain Layout

>>> currentTime.printTime() 
\end_layout

\begin_layout Plain Layout

9:0:0
\end_layout

\begin_layout Plain Layout

>>> currentTime = Time(seconds = 30, hours = 9) 
\end_layout

\begin_layout Plain Layout

>>> currentTime.printTime() 
\end_layout

\begin_layout Plain Layout

9:0:30
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
to overide an esiting method for a class use the __ methods
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Point: 
\end_layout

\begin_layout Plain Layout

	def __init__(self, x=0, y=0): 
\end_layout

\begin_layout Plain Layout

		self.x = x 
\end_layout

\begin_layout Plain Layout

		self.y = y 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def __str__(self): 
\end_layout

\begin_layout Plain Layout

		return ’(’ + str(self.x) + ’, ’ + str(self.y) + ’)’
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

p=Point(3,4)
\end_layout

\begin_layout Plain Layout

str(p)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
overiding operators again use __
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Point: 
\end_layout

\begin_layout Plain Layout

	# previously defined methods here...
 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	def __add__(self, other): 
\end_layout

\begin_layout Plain Layout

		return Point(self.x + other.x, self.y + other.y)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> p1 = Point(3, 4) 
\end_layout

\begin_layout Plain Layout

>>> p2 = Point(5, 7) 
\end_layout

\begin_layout Plain Layout

>>> p3 = p1 + p2 
\end_layout

\begin_layout Plain Layout

>>> print p3 
\end_layout

\begin_layout Plain Layout

(8, 11)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#p1 + p2 is the same as p1.__add__(p2)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
substitutions
\end_layout

\begin_deeper
\begin_layout Itemize
+ __add__
\end_layout

\begin_layout Itemize
* __mul__ __rmul__ p.
 183
\end_layout

\end_deeper
\begin_layout Section*
Chapter 15 sets of objects
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Card: 
\end_layout

\begin_layout Plain Layout

	suitList = ["Clubs", "Diamonds", "Hearts", "Spades"] 
\end_layout

\begin_layout Plain Layout

	rankList = ["narf", "Ace", "2", "3", "4", "5", "6", "7", 
\end_layout

\begin_layout Plain Layout

				"8", "9", "10", "Jack", "Queen", "King"]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def __init__(self, suit=0, rank=2): 
\end_layout

\begin_layout Plain Layout

		self.suit = suit 
\end_layout

\begin_layout Plain Layout

		self.rank = rank
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	def __str__(self): 
\end_layout

\begin_layout Plain Layout

		return (self.rankList[self.rank] + " of " + 
\end_layout

\begin_layout Plain Layout

				self.suitList[self.suit])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

threeOfClubs = Card(3, 1)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
can overide == and the like with _cmp_ p.
 191
\end_layout

\begin_layout Section*
Chapter 16 inheritance
\end_layout

\begin_layout Itemize
inheritance is defined in the class def 
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Hand(Deck):
\end_layout

\begin_layout Plain Layout

	pass
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
how one class uses the inherited stuff
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> deck = Deck() 
\end_layout

\begin_layout Plain Layout

>>> deck.shuffle() 
\end_layout

\begin_layout Plain Layout

>>> hand = Hand("frank") 
\end_layout

\begin_layout Plain Layout

>>> deck.deal([hand], 5) 
\end_layout

\begin_layout Plain Layout

>>> print hand 
\end_layout

\begin_layout Plain Layout

Hand frank contains 
\end_layout

\begin_layout Plain Layout

2 of Spades 
\end_layout

\begin_layout Plain Layout

 3 of Spades 
\end_layout

\begin_layout Plain Layout

  4 of Spades 
\end_layout

\begin_layout Plain Layout

   Ace of Hearts 
\end_layout

\begin_layout Plain Layout

    9 of Clubs
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
how to intermingle methods of same name
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Hand(Deck) 
\end_layout

\begin_layout Plain Layout

	...
 
\end_layout

\begin_layout Plain Layout

	def __str__(self): 
\end_layout

\begin_layout Plain Layout

		s = "Hand " + self.name 
\end_layout

\begin_layout Plain Layout

		if self.isEmpty(): 
\end_layout

\begin_layout Plain Layout

			return s + " is empty
\backslash
n" 
\end_layout

\begin_layout Plain Layout

		else: 
\end_layout

\begin_layout Plain Layout

			return s + " contains
\backslash
n" + Deck.__str__(self)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
SKIPPED A LOT, LOOK AT IF NEED TO KNOW INHERITANCE
\end_layout

\begin_layout Section
Software Design: 
\end_layout

\begin_layout Standard
algorithm
\end_layout

\begin_layout Section
Software Design
\end_layout

\begin_layout Standard
software
\end_layout

\begin_layout Itemize
remember we're buildling games
\end_layout

\begin_deeper
\begin_layout Itemize
have them them define what a game is
\end_layout

\begin_deeper
\begin_layout Itemize
they are wrong
\end_layout

\end_deeper
\begin_layout Itemize
a game is fun, interactive, and has rewards
\end_layout

\begin_deeper
\begin_layout Itemize
this is fundemental
\end_layout

\begin_layout Itemize
they need to think about this when designing their games
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
Game Pitch Day 
\end_layout

\begin_layout Section
Project Managment/Exceptions and Files Chapter 14
\end_layout

\begin_layout Itemize
goals 
\end_layout

\begin_layout Itemize
virtical slices 
\end_layout

\begin_layout Itemize
timelines 
\end_layout

\begin_layout Itemize
more github 
\end_layout

\begin_layout Itemize
we require
\end_layout

\begin_deeper
\begin_layout Itemize
Apr 9: Virtical Slice
\end_layout

\begin_deeper
\begin_layout Itemize
no graphics
\end_layout

\begin_layout Itemize
proof of concept/core game play elements
\end_layout

\end_deeper
\begin_layout Itemize
Apr 23: Virtical Slice
\end_layout

\begin_deeper
\begin_layout Itemize
game must be playable
\end_layout

\begin_layout Itemize
does not yet need graphics
\end_layout

\begin_layout Itemize
all parts of game must be implemented 
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Exceptions and Files Chapter 11 
\end_layout

\begin_layout Itemize
open a file
\end_layout

\begin_deeper
\begin_layout Itemize
f = open("test.dat","w")
\end_layout

\end_deeper
\begin_layout Itemize
write to a file
\end_layout

\begin_deeper
\begin_layout Itemize
f.write("Now is the time")
\end_layout

\begin_layout Itemize
can only write strings
\end_layout

\begin_deeper
\begin_layout Itemize
f.write (str(x))
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
close a file
\end_layout

\begin_deeper
\begin_layout Itemize
f.close()
\end_layout

\end_deeper
\begin_layout Itemize
read a file
\end_layout

\begin_deeper
\begin_layout Itemize
entire file
\end_layout

\begin_deeper
\begin_layout Itemize
text=f.read()
\end_layout

\end_deeper
\begin_layout Itemize
set number of characters
\end_layout

\begin_deeper
\begin_layout Itemize
text=f.read(5)
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
read a line
\end_layout

\begin_deeper
\begin_layout Itemize
f.readline()
\end_layout

\begin_layout Itemize
reads to and includes the 
\backslash
n
\end_layout

\end_deeper
\begin_layout Itemize
read lines
\end_layout

\begin_deeper
\begin_layout Itemize
f.readlines()
\end_layout

\begin_layout Itemize
returns a list of strings
\end_layout

\end_deeper
\begin_layout Itemize
break statement introduced p.
 147
\end_layout

\begin_layout Itemize
formatting strings
\end_layout

\begin_deeper
\begin_layout Itemize
"In July we sold %d cars." % cars
\end_layout

\begin_layout Itemize
%d int
\end_layout

\begin_layout Itemize
%f float
\end_layout

\begin_layout Itemize
%s strings
\end_layout

\begin_layout Itemize
typical C style formatting
\end_layout

\end_deeper
\begin_layout Itemize
pickling
\end_layout

\begin_deeper
\begin_layout Itemize
write data to files not as strings
\end_layout

\begin_layout Itemize
import pickle
\end_layout

\begin_layout Itemize
f = open("test.pck","w")
\end_layout

\begin_layout Itemize
pickle.dump(12.3, f)
\end_layout

\begin_layout Itemize
x = pickle.load(f)
\end_layout

\end_deeper
\begin_layout Itemize
throwing exceptions p.
 153
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

filename = raw_input(’Enter a file name: ’) 
\end_layout

\begin_layout Plain Layout

try: 
\end_layout

\begin_layout Plain Layout

	f = open (filename, "r") 
\end_layout

\begin_layout Plain Layout

except IOError: 
\end_layout

\begin_layout Plain Layout

	print ’There is no file named’, filename
\end_layout

\end_inset


\end_layout

\begin_layout Section
Plan Review/Work Day 
\end_layout

\begin_layout Itemize
attendance is mandetory 
\end_layout

\begin_layout Section
Recursion Data Structures 
\end_layout

\begin_layout Itemize
VIRTICAL SLICE DUE
\end_layout

\begin_layout Itemize
linked lists 
\end_layout

\begin_layout Itemize
talk about mazes
\end_layout

\begin_layout Section
Data Structures 
\end_layout

\begin_layout Itemize
trees 
\end_layout

\begin_layout Itemize
graphs 
\end_layout

\begin_layout Section
State Machines 
\end_layout

\begin_layout Itemize
animation
\end_layout

\begin_layout Itemize
sprite sheets
\end_layout

\begin_layout Itemize
use Pac-man to explain state machines
\end_layout

\begin_layout Section
Animation and Sound
\end_layout

\begin_layout Section
Real World Python 
\end_layout

\begin_layout Itemize
show them how to find libraries
\end_layout

\begin_layout Itemize
VIRTICAL SLICE DUE
\end_layout

\begin_layout Itemize
the example is a deathfest character generator
\end_layout

\begin_layout Itemize
building command line programs
\end_layout

\begin_layout Itemize
GUI
\end_layout

\begin_deeper
\begin_layout Itemize
show them how they can build real stand along programs
\end_layout

\end_deeper
\begin_layout Section
Real World Python 
\end_layout

\begin_layout Itemize
shift the deathfest character stuff to the web
\end_layout

\begin_layout Itemize
mention web scraping
\end_layout

\begin_layout Itemize
life hacking
\end_layout

\begin_layout Section
Play Final Games Course Wrap-Up 
\end_layout

\begin_layout Section
Present Final Games
\end_layout

\begin_layout Section*
not yet in notes
\end_layout

\end_body
\end_document
